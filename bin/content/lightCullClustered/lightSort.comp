#version 450

#include "../lightCullAdaptive/tileLights.glsl"

cconst TREE_MAX_DEPTH;
cconst MAX_LIGHTS_PER_TILE;
cconst TILE_COUNT_X;

struct LightData
{
    vec3 position;
    float strength;
    vec3 color;
    float padding;
};

layout(std430) buffer Lights
{
    vec3 padding;
    float ambientStrength;
    LightData lights[];
};

layout(std430) buffer OutLightIndices
{
    int outLightIndices[];
};

uniform int logSize;
//uniform int startIndex;

shared int loadedData[MAX_LIGHTS_PER_TILE];
shared float lightZPosition[MAX_LIGHTS_PER_TILE];

layout(local_size_y = MAX_LIGHTS_PER_TILE) in;
void main()
{
    int threadID = int(gl_LocalInvocationID.y);

    int startIndex = (int(gl_WorkGroupID.y) * TILE_COUNT_X + int(gl_WorkGroupID.x)) * MAX_LIGHTS_PER_TILE;
    int lightIndex = GetLightIndex(startIndex + threadID);

    loadedData[threadID] = lightIndex;

    if(lightIndex != -1)
        lightZPosition[threadID] = lights[loadedData[threadID]].position.x;
    else
        lightZPosition[threadID] = 3.4e30f;

    memoryBarrier();
    barrier();

    for(int pass = 0; pass < logSize; ++pass)
    {
        for(int section = 0; section <= pass; ++section)
        {
            const int distance = 1 << (pass - section);

            bool up = ((threadID >> pass) & 2) == 0;

            int lhs = threadID;
            int rhs = threadID | distance;

            float lhsZ = lightZPosition[lhs];
            float rhsZ = lightZPosition[rhs];

            if((threadID & distance) == 0 && (lhsZ > rhsZ) == up)
            {
                int temp = loadedData[lhs];
                loadedData[lhs] = loadedData[rhs];
                loadedData[rhs] = temp;

                float tempf = lightZPosition[lhs];
                lightZPosition[lhs] = lightZPosition[rhs];
                lightZPosition[rhs] = tempf;
            }

            memoryBarrier();
            barrier();
        }

        memoryBarrier();
        barrier();
    }

    outLightIndices[startIndex + threadID] = loadedData[threadID];
}