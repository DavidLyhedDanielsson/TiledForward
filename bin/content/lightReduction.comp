#version 450 core

#include "commonIncludes.glsl"

uniform mat4 viewMatrix;
uniform mat4 projectionInverseMatrix;

#include "planes.glsl"

layout(std430) buffer OldLightIndices
{
    int oldOccupiedIndices; // Needs to be initialized to 0!
    int oldLightIndices[];
};

layout(std430) buffer OldTileLights
{
    TileLightData oldTileLightData[];
};

layout(std430) buffer OldPixelToTile
{
    int oldPixelTileIndex[];
};

layout(std430) buffer NewLightIndices
{
    int newOccupiedIndices; // Needs to be initialized to 0!
    int newLightIndices[];
};

layout(std430) buffer NewTileLights
{
    TileLightData newTileLightData[];
};

layout(std430) buffer NewPixelToTile
{
    int newPixelTileIndex[];
};

shared int lightCount;
shared int localLightIndices[MAX_LIGHTS_PER_TILE];

//shared int currentStartIndex;
//shared int currentLightCount;

//uniform int workGroupCountX;

//layout(std430) buffer CurrentLightIndices
//{
//    int currentOccupiedIndices; // Needs to be initialized to 0!
//    int currentLightIndices[];
//};
//
//layout(std430) buffer CurrentTileLights
//{
//    TileLightData currentTileLightData[];
//};

void AddLightIfPossible(int lightIndex)
{
    int index = atomicAdd(lightCount, 1);

    //if(index < MAX_LIGHTS_PER_TILE)
    //    localLightIndices[index] = lightIndex;
}

layout(local_size_x = THREADS_PER_GROUP_X, local_size_y = THREADS_PER_GROUP_Y) in;
void main()
{
    if(gl_LocalInvocationIndex == 0)
    {
        lightCount = 0;

        //int arrayIndex = GetArrayIndex(gl_WorkGroupID.xy / 2, 10);

        //currentStartIndex = currentTileLightData[arrayIndex].start;
        //currentLightCount = currentTileLightData[arrayIndex].numberOfLights;
    }

    barrier();

    //if(currentLightCount > 0)
    //{
        //for(int i = int(gl_LocalInvocationIndex); i < currentLightCount; i += int(THREADS_PER_GROUP_X * THREADS_PER_GROUP_Y))
        for(int i = int(gl_LocalInvocationIndex); i < 64; i += int(THREADS_PER_GROUP_X * THREADS_PER_GROUP_Y))
        {
            //LightData light = lights[currentLightIndices[currentStartIndex + i]];
            LightData light = lights[i];

            vec3 viewPositions[5] = CreateFarPoints(uvec2(64, 64));
            vec4 planes[4] = CreatePlanes(viewPositions);

            vec3 zeroPos = vec3(viewMatrix * vec4(light.position, 1.0f));

            if(dot(zeroPos, zeroPos) > light.strength * light.strength)
            {
                bool inside = false;

                vec3 planeForward = normalize(viewPositions[CENTER]);
                if(dot(normalize(zeroPos), planeForward) > 0.0f)
                {
                    inside = true;

                    for(int j = 0; j < 4; ++j)
                    {
                        float dist = dot(zeroPos, vec3(planes[j])) + planes[j].w;
                        if(dist < -light.strength)
                        {
                            inside = false;
                            break;
                        }
                    }
                }

                if(inside)
                    AddLightIfPossible(i);
            }
            else
                AddLightIfPossible(i);
        }
    //}

    barrier();

    if(gl_LocalInvocationIndex == 0)
    {
        int arrayIndex = GetArrayIndex(gl_WorkGroupID.xy, 20);
        int startIndex = arrayIndex * MAX_LIGHTS_PER_TILE;

        int cappedLightCount = min(lightCount, MAX_LIGHTS_PER_TILE);
        for(int i = 0; i < cappedLightCount; ++i)
            newLightIndices[startIndex + i] = localLightIndices[i];
        for(int i = cappedLightCount; i < MAX_LIGHTS_PER_TILE; ++i)
            newLightIndices[startIndex + i] = -1;

        TileLightData data;
        data.start = startIndex;
        data.numberOfLights = lightCount;
        data.padding = ivec2(gl_WorkGroupID) * ivec2(64, 64);

        newTileLightData[arrayIndex] = data;
    }
}