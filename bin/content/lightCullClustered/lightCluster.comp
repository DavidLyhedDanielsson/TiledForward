#version 450 core

//#include "commonIncludes.glsl"
//#include "../lightCullAdaptive/tree.glsl"
#include "../lightCullAdaptive/tileLights.glsl"

cconst TREE_MAX_DEPTH;
cconst BUCKET_COUNT;
cconst MAX_LIGHTS_PER_TILE;

struct LightData
{
    vec3 position;
    float strength;
    vec3 color;
    float padding;
};

layout(std430) buffer Lights
{
    vec3 padding;
    float ambientStrength;
    LightData lights[];
};

layout(std140) buffer FinalLights
{
    LightData[] finalLights;
};

layout(std430) buffer Tree
{
    int tree[];
};

int GetTreeLinearIndex(int x, int y)
{
    int index = 0;

    for(int i = 0; i < 32; ++i)
    {
        int extractedBit;

        if(i % 2 == 0)
            extractedBit = ((x >> (i / 2)) & 1);
        else
            extractedBit = (y >> (i / 2)) & 1;

        index |= (extractedBit << i);
    }

    return index;
}

int GetTreeDataGrid(int x, int y, int depth)
{
    int depthOffset = -1;

    for(int i = 0; i < depth; ++i)
        depthOffset += int(pow(4, i));

    int index = GetTreeLinearIndex(x, y);
    return tree[depthOffset + index];
}

layout(local_size_x = 1, local_size_y = 1) in;
void main()
{
    int lightStartIndex;
    int lightCount;

    //////////////////////////////////////////////////
    // Get light data
    int index = GetTreeDataGrid(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y), TREE_MAX_DEPTH);

    TileLightData lightData = GetTileLightData(index);
    lightStartIndex = lightData.start;
    lightCount = lightData.numberOfLights;

    if(lightCount > 0)
    {
        int bucket = 0;
        int lightsInBucket = 1;

        // Copy to local array
        LightData localLights[MAX_LIGHTS_PER_TILE];
        for(int i = 0; i < lightCount; ++i)
            localLights[i] = lights[GetLightIndex(lightStartIndex + i)];

        // Final array, this is written back to VRAM
        LightData localFinalLights[BUCKET_COUNT];

        //////////////////////////////////////////////////
        // Cluster lights
        LightData currentLightData = localLights[0];
        vec3 bucketPosition = currentLightData.position;
        for(int i = 1; i < lightCount; ++i)
        {
            LightData current = localLights[i];

            /*float distance = distance(bucketPosition, current.position);

            if(distance > 1.0f)
            {
                // Put final cluster info "localFinalLights"
                // and increase bucket count
                currentLightData.position /= lightsInBucket;
                currentLightData.color /= lightsInBucket;
                localFinalLights[bucket] = currentLightData;

                ++bucket;
                lightsInBucket = 1;

                currentLightData = current;
                bucketPosition = currentLightData.position;
            }
            else*/
            {
                // Add light to cluster
                currentLightData.position += current.position;
                currentLightData.strength += current.strength;
                currentLightData.color += current.color;

                ++lightsInBucket;
            }
        }

        currentLightData.position /= lightsInBucket;
        currentLightData.color /= lightsInBucket;
        localFinalLights[bucket] = currentLightData;

        ++bucket;

        // Write final lights to VRAM
        for(int i = 0; i < bucket; ++i)
            finalLights[(gl_WorkGroupID.y * gl_NumWorkGroups.y + gl_WorkGroupID.x) * BUCKET_COUNT + i] = localFinalLights[i];
    }
}
