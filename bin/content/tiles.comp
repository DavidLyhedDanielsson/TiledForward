#version 450 core

#define cppint(a) const int a = 1;

cppint(WORK_GROUP_WIDTH)
cppint(WORK_GROUP_HEIGHT)

layout(location = 0, rgba8) uniform image2DMS inImage;
layout(location = 1) uniform sampler2DMS depthBuffer;
//layout(location = 1, rgba8) uniform image2DMS outImage;

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 projectionInverseMatrix;
uniform mat4 viewInverseMatrix;

struct LightData
{
    vec3 position;
    float strength;
    vec3 color;
    float padding;
};

layout(std140) buffer Lights
{
    vec3 padding;
    float ambientStrength;
    LightData lights[];
};

layout(std140) buffer ScreenSize
{
    int screenWidth;
    int screenHeight;
};

const int LOCAL_LIGHT_COUNT = 64;

shared int lightCount;
shared uint lightIndices[LOCAL_LIGHT_COUNT];

const int MSAA_COUNT = 2;

const int PLANE_TOP = 0;
const int PLANE_BOTTOM = 1;
const int PLANE_LEFT = 2;
const int PLANE_RIGHT = 3;

vec4 CreatePlane(vec3 far0, vec3 far1)
{
    vec3 planeABC;
    planeABC = normalize(cross(far0, far1));
    float dist = dot(far0, planeABC);

    return vec4(planeABC, dist);
}

layout(local_size_x = WORK_GROUP_WIDTH, local_size_y = WORK_GROUP_HEIGHT) in;
void main()
{
    float depth = 0.0f;
    for(int i = 0; i < MSAA_COUNT; ++i)
        depth += texelFetch(depthBuffer, ivec2(gl_GlobalInvocationID), i).x;

    depth /= 2.0f;
    depth = 1.0f - depth;

    vec4 unprojectedDepth = projectionInverseMatrix * vec4(0.0f, 0.0f, depth, 1.0f);
    depth = unprojectedDepth.z / unprojectedDepth.w;

    if(gl_GlobalInvocationID.x > screenWidth / 2)
        for(int i = 0; i < MSAA_COUNT; ++i)
            imageStore(inImage, ivec2(gl_GlobalInvocationID), i, vec4(depth / 100.0f, depth / 100.0f, depth / 100.0f, 1.0f));

    /*if(gl_LocalInvocationIndex == 0)
        lightCount = 0;

    barrier();

    for(uint i = gl_LocalInvocationIndex; i < lights.length(); i += gl_WorkGroupSize.x * gl_WorkGroupSize.y)
    {
        LightData light = lights[i];

        const int TOP_LEFT = 3;
        const int TOP_RIGHT = 2;
        const int BOTTOM_RIGHT = 1;
        const int BOTTOM_LEFT = 0;

        const ivec2 offsets[4] =
        {
            ivec2(0, 0)
            , ivec2(1, 0)
            , ivec2(1, 1)
            , ivec2(0, 1)
        };

        vec3 viewPositions[4];

        for(int j = 0; j < 4; ++j)
        {
            vec3 ndcPosition = vec3(vec2((gl_WorkGroupID.xy + offsets[j]) * gl_WorkGroupSize.xy)
                                              / vec2(screenWidth, screenHeight), 1.0f);
            ndcPosition.x *= 2.0f;
            ndcPosition.x -= 1.0f;
            ndcPosition.y *= 2.0f;
            ndcPosition.y -= 1.0f;

            vec4 unprojectedPosition = projectionInverseMatrix * vec4(ndcPosition, 1.0f);
            unprojectedPosition /= unprojectedPosition.w;

            viewPositions[j] = vec3(unprojectedPosition);
        }

        vec4 planes[4];
        planes[PLANE_TOP] = CreatePlane(viewPositions[TOP_LEFT], viewPositions[TOP_RIGHT]);
        planes[PLANE_BOTTOM] = CreatePlane(viewPositions[BOTTOM_RIGHT], viewPositions[BOTTOM_LEFT]);
        planes[PLANE_RIGHT] = CreatePlane(viewPositions[TOP_RIGHT], viewPositions[BOTTOM_RIGHT]);
        planes[PLANE_LEFT] = CreatePlane(viewPositions[BOTTOM_LEFT], viewPositions[TOP_LEFT]);

        vec3 zeroPos = vec3(viewMatrix * vec4(light.position, 1.0f));

        bool inside = true;
        for(int j = 0; j < 4; ++j)
        {
            float dist = dot(zeroPos, vec3(planes[j])) + planes[j].w;
            if(dist > light.strength)
                inside = false;
        }

        if(inside)
        {
            if(zeroPos.z < 0)
                inside = false;
        }

        if(inside)
        {
            lightIndices[atomicAdd(lightCount, 1)] = i;
        }
    }

    barrier();

    if(lightCount != 0)
    {
        const float opacity = 0.5f;

        vec3 currentColor = vec3(0.0f);
        for(int i = 0; i < MSAA_COUNT; ++i)
            currentColor += imageLoad(inImage, ivec2(gl_GlobalInvocationID), i).xyz;
        currentColor /= float(MSAA_COUNT);

        vec3 lightColor = vec3(0.0f);
        for(int i = 0; i < lightCount; ++i)
            lightColor += lights[lightIndices[i]].color;

        float maxLength = max(max(lightColor.x, lightColor.y), lightColor.z);
        lightColor = normalize(lightColor) * min(maxLength, 1.0f);

        vec3 finalColor = currentColor * opacity + lightColor * (1.0f - opacity);

        for(int i = 0; i < MSAA_COUNT; ++i)
            imageStore(inImage, ivec2(gl_GlobalInvocationID), i, vec4(finalColor, 1.0f));
    }*/
}